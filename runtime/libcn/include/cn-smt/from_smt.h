#ifndef CN_SMT_FROM_SMT_H
#define CN_SMT_FROM_SMT_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include <bennet/utils/hash_table.h>
#include <bennet/utils/optional.h>
#include <cn-smt/sexp.h>
#include <cn-smt/solver.h>
#include <cn-smt/terms.h>

#ifdef __cplusplus
extern "C" {
#endif

// Forward declarations and types
typedef const char* const_char_ptr;
typedef sexp_t* sexp_ptr;

// Hash table for string -> sexp mapping (used in let-bindings)
BENNET_HASH_TABLE_DECL(const_char_ptr, sexp_ptr)

// Optional types
BENNET_OPTIONAL_DECL(sexp_ptr);

// Struct for let-binding result
typedef struct {
  bennet_hash_table(const_char_ptr, sexp_ptr) bindings;
  sexp_t* body;
} let_binding_t;

BENNET_OPTIONAL_DECL(let_binding_t);

// Struct for constructor decoding result
typedef struct {
  const char* name;
  sexp_t** fields;
  size_t field_count;
} constructor_result_t;

// Struct for array decoding result
typedef struct {
  struct {
    sexp_t* key;
    sexp_t* value;
  }* pairs;
  size_t pair_count;
  sexp_t* default_value;
} array_result_t;

/** {2 Decoding Results} */

/** Get all definitions currently in scope. Only valid after a [Sat] result.
    See also {!model_eval}. */
sexp_t* get_model(struct cn_smt_solver* s);

/** Get the values of some s-expressions. Only valid after a [Sat] result.
    Throws {!UnexpectedSolverResponse}. */
sexp_t** get_exprs(
    struct cn_smt_solver* s, sexp_t** vals, size_t val_count, size_t* result_count);

/** Evaluate the given expression in the current context.
    Only valid after a [Sat] result.
    Throws {!UnexpectedSolverResponse}. */
sexp_t* get_expr(struct cn_smt_solver* s, sexp_t* v);

/** Check if expression is a let-binding and extract bindings and body */
bennet_optional(let_binding_t) is_let(sexp_t* exp);

/** Expand let-definitions in this term.
    NOTE: this is intended to be used mostly on models generated by the
    solver (e.g., `get-value` in Z3 sometimes contains `let`).  As such
    we assume that `forall` and `exist` won't occur, and so we don't need
    to check for variable capture. */
sexp_t* no_let(sexp_t* exp0);

/** Try to decode an s-expression as a boolean
    Throws {!UnexpectedSolverResponse}. */
bool to_bool(sexp_t* exp);

/** Try to decode an s-expression as a bitvector of the given width.
    The 2nd argument indicates if the number is signed.
    Throws {!UnexpectedSolverResponse}. */
int64_t to_bits(int w, bool signed_val, sexp_t* exp);

/** Try to decode an s-expression as an integer.
    Throws {!UnexpectedSolverResponse}. */
int64_t to_z(sexp_t* exp);

/** Try to decode an s-expression as a rational number.
    Throws {!UnexpectedSolverResponse}. */
double to_q(sexp_t* exp);

/** Try to decode an s-expression as constructor with field values.
    Throws {!UnexpectedSolverResponse}. */
constructor_result_t to_con(sexp_t* exp);

/** Try to decode an s-expression as an array. The result is `(is,v)`
    where is are (key,value) pairs, and `v` is the default array value.
    Throws {!UnexpectedSolverResponse}. */
array_result_t to_array(sexp_t* exp0);

// Memory management functions
void free_constructor_result(constructor_result_t* result);
void free_array_result(array_result_t* result);
void free_let_binding(let_binding_t* binding);

// Forward declaration for globals structure (simplified)
struct globals {
  void* struct_decls;
  void* datatypes;
  void* datatype_constrs;
};

/** {1 SMT to Term} */

/** Translate an SMT value to a CN term */
cn_term* get_ivalue(cn_base_type bt, sexp_t* sexp);

/** Get the value from an SMT s-expression based on base type */
cn_term* get_value(cn_base_type bt, sexp_t* sexp);

#ifdef __cplusplus
}
#endif

#endif  // CN_SMT_FROM_SMT_H
